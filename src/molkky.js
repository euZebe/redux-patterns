/*
  ACTION : Object { type: xxx, [...otherAttributes] }
  often generated by ACTION CREATORS
 */

/**
 * @param players: string[]
 * @returns {{ type: string, players: string[] }}
 */
export function initGame(players) {
  console.log('=> jeu initialisÃ©');
  return {
    type: 'INIT_SCORES_SHEET',
    players, // same as players: players
  };
}

/**
 *
 * @param fallenPins: number[]
 * @param player: string
 * @returns {{ type: string, player: string, fallenPins: number[] }}
 */
export function throwPin(fallenPins = [], player) {
  if (fallenPins.length) {
    console.log(`${player} a fait tomber la/les quille(s) ${fallenPins}`);
  } else {
    console.log(`${player} n'a fait tomber aucune quille`);
  }
  return {
    type: 'THROW',
    player,
    fallenPins,
  };
}


/*
  REDUCER
 */

/**
 * @param previousState shape = {
 *    fallenPins: number,
 *    playerX: {      // iterated over players
 *      name: string,
 *      score: number,
 *      consecutiveFailures: number,
 *    }
 * }
 * @param action
 * @returns a new state, with the shape described above
 */
export default function reducer(previousState = {}, action) {
  switch (action.type) {

    case 'INIT_SCORES_SHEET':
      return action.players.reduce((aggregator, player) => {
        aggregator[player] = {
          name: player,
          score: 0,
          consecutiveFailures: 0,
        };
        return aggregator;
      }, {});

    case 'THROW':
      const { player, fallenPins } = action;
      const previousPlayerState = previousState[player];

      // no pin fell
      if (!fallenPins.length) {
        const nextPlayerState = {
          ...previousPlayerState,
          consecutiveFailures: previousPlayerState.consecutiveFailures + 1, // pas de ++, on ne modifie pas previousPlayerState
        };
        return {
          ...previousState,
          fallenPins: fallenPins.length,
          [player]: nextPlayerState,
        };
      }

      // one pin fell
      if (fallenPins.length === 1) {
        const nextPlayerState = {
          ...previousPlayerState,
          score: previousPlayerState.score + fallenPins[0],
          consecutiveFailures: 0,
        };
        return {
          ...previousState,
          fallenPins: fallenPins.length,
          [player]: nextPlayerState,
        };
      }

      // else, several pins fell

      // FIXME: toggle this block and the next one to make reducer unpure
      const nextPlayerState = {
        ...previousPlayerState,
        score: previousPlayerState.score + fallenPins.length,
        consecutiveFailures: 0,
      };
      return {
        ...previousState,
        fallenPins: fallenPins.length,
        [player]: nextPlayerState
      };

    // FIXME: unpure reducer: state mutated => audience and referee won't see the action
    // previousState[player].score += fallenPins.length;
    // previousState[player].consecutiveFailures = 0;
    // previousState.fallenPins = fallenPins.length;
    // return previousState;

    // FIXME: unpure reducer: nested state mutated => player listener won't see the action
    // FIXME: !! BobListener listens modifications on Bob's substate
    // const nextState = { ...previousState, fallenPins: fallenPins.length };
    // nextState[player].consecutiveFailures = 0;
    // nextState[player].score += fallenPins.length;
    // return nextState;

    default:
      return previousState;
  }
}

export const getPlayerState = (state, playerName) => state[playerName];

export const getFallenPins = state => state.fallenPins;
